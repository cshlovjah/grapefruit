// Combined file generated by uRequire v0.5.0, with help from r.js & almond
(function (){
  var __isAMD = (typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;


  var __global = null,
      __nodeRequire = function(){};

  if (__isNode) {
      __nodeRequire = require;
      __global = global;
  } else {
      __global = window;
  };

  factory = function() {
/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

(function (window) {
  define(
  'core/plugin',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
var plugin = module.exports = {
    patch: function(obj, name, fn) {
        if (obj.prototype !== undefined) {
            obj = obj.prototype;
        }
        if (typeof obj[name] === "function" && typeof fn === "function") {
            var _super = obj[name];
            obj[name] = function(name, fn) {
                return function() {
                    var tmp = this._super;
                    this._super = _super;
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            }(name, fn);
        } else {
            throw name + " is not a function in the passed object.";
        }
    },
    register: function(plugin, name) {
        if (gf[name]) {
            throw 'Grapefruit: Unable to register plugin: "' + name + '" already exists in the gf namespace, please choose something else!';
        }
        if (plugin.gfVersion && !semver.satisfies(gf.version, plugin.gfVersion)) {
            throw "GrapeFruit: Plugin gfVersion mismatch, need grapefruit version " + plugin.gfVersion + ", but using version " + gf.version;
        }
        gf[name] = plugin;
    }
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/utils/EventEmitter',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
var EventEmitter = module.exports = function() {
    this._events = this._events || {};
    this.addEventListener = this.on = function(type, listener) {
        if (typeof listener !== "function") throw new TypeError("listener must be a function");
        if (!this._events) this._events = {};
        if (!this._events[type]) this._events[type] = listener; else if (typeof this._events[type] === "object") this._events[type].push(listener); else this._events[type] = [ this._events[type], listener ];
        return this;
    };
    this.dispatchEvent = this.emit = function(type) {
        var handler, len, args, i, listeners;
        if (!this._events) this._events = {};
        handler = this._events[type];
        if (typeof handler === "undefined") return false;
        if (typeof handler === "function") {
            switch (arguments.length) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                handler.apply(this, args);
            }
        } else if (typeof handler === "object") {
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++) args[i - 1] = arguments[i];
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++) listeners[i].apply(this, args);
        }
        return this;
    };
    this.removeEventListener = this.off = function(type, listener) {
        var list, position, length, i;
        if (typeof listener !== "function") throw new TypeError("listener must be a function");
        if (!this._events[type]) return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || typeof list.listener === "function" && list.listener === listener) {
            this._events[type] = undefined;
        } else if (typeof list === "object") {
            for (i = length; i-- > 0; ) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                    position = i;
                    break;
                }
            }
            if (position < 0) return this;
            if (list.length === 1) {
                list.length = 0;
                this._events[type] = undefined;
            } else {
                list.splice(position, 1);
            }
        }
    };
    this.once = function(type, listener) {
        if (typeof listener !== "function") throw new TypeError("listener must be a function");
        function g() {
            this.off(type, g);
            listener.apply(this, arguments);
        }
        g.listener = listener;
        this.on(type, g);
        return this;
    };
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/math/Vector',['require', 'exports', 'module', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var utils = require("../utils/utils");

var Vector = module.exports = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
};

utils.inherits(Vector, Object, {
    set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index);
        }
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    },
    add: function(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
    },
    sub: function(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    },
    multiplyScalar: function(s) {
        this.x *= s;
        this.y *= s;
        return this;
    },
    divideScalar: function(s) {
        if (s !== 0) {
            this.x /= s;
            this.y /= s;
        } else {
            this.set(0, 0);
        }
        return this;
    },
    min: function(v) {
        if (this.x > v.x) {
            this.x = v.x;
        }
        if (this.y > v.y) {
            this.y = v.y;
        }
        return this;
    },
    max: function(v) {
        if (this.x < v.x) {
            this.x = v.x;
        }
        if (this.y < v.y) {
            this.y = v.y;
        }
        return this;
    },
    clamp: function(min, max) {
        if (this.x < min.x) {
            this.x = min.x;
        } else if (this.x > max.x) {
            this.x = max.x;
        }
        if (this.y < min.y) {
            this.y = min.y;
        } else if (this.y > max.y) {
            this.y = max.y;
        }
        return this;
    },
    negate: function() {
        return this.multiplyScalar(-1);
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length());
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    },
    setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
            this.multiplyScalar(l / oldLength);
        }
        return this;
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y;
    },
    toArray: function() {
        return [ this.x, this.y ];
    },
    clone: function() {
        return new Vector(this.x, this.y);
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/math/Circle',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = PIXI.Circle;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/math/Rectangle',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = PIXI.Rectangle;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/math/Polygon',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = PIXI.Rectangle;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/utils/utils',['require', 'exports', 'module', '../math/Vector', '../math/Circle', '../math/Rectangle', '../math/Polygon'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Vector = require("../math/Vector"), Circle = require("../math/Circle"), Rectangle = require("../math/Rectangle"), Polygon = require("../math/Polygon");

var utils = module.exports = {
    _arrayDelim: /[|,]/,
    ensureVector: function(vec) {
        if (vec instanceof Vector) return vec;
        var a = vec;
        if (typeof vec === "string") a = vec.split(utils._arrayDelim);
        if (a instanceof Array) {
            switch (a.length) {
              case 1:
                return new Vector(parseFloat(a[0], 10) || 0, parseFloat(a[0], 10) || 0);
              case 2:
                return new Vector(parseFloat(a[0], 10) || 0, parseFloat(a[1], 10) || 0);
            }
        } else if (typeof a === "number") {
            return new Vector(a, a);
        } else {
            return new Vector;
        }
    },
    noop: function() {},
    ajax: function(sets) {
        sets = sets || {};
        sets.method = sets.method || "GET";
        sets.dataType = sets.dataType || "text";
        if (!sets.url) throw "No URL passed to ajax";
        sets.progress = sets.progress || utils.noop;
        sets.load = sets.load || utils.noop;
        sets.error = sets.error || utils.noop;
        sets.abort = sets.abort || utils.noop;
        sets.complete = sets.complete || utils.noop;
        var xhr = utils.createAjaxRequest();
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                var res = xhr.response || xhr.responseText, err = null;
                if (xhr.status !== 200) err = "Non-200 status code returned: " + xhr.status;
                if (!err && typeof res === "string" && sets.dataType === "json") {
                    try {
                        res = JSON.parse(res);
                    } catch (e) {
                        err = e;
                    }
                }
                if (err) {
                    if (sets.error) sets.error.call(xhr, err);
                } else {
                    if (sets.load) sets.load.call(xhr, res);
                }
            }
        };
        if (sets.dataType !== "json") xhr.responseType = sets.dataType;
        xhr.open(sets.method, sets.url, true);
        xhr.send();
        return xhr;
    },
    createAjaxRequest: function() {
        var activexmodes = [ "Msxml2.XMLHTTP", "Microsoft.XMLHTTP" ];
        if (window.ActiveXObject) {
            for (var i = 0; i < activexmodes.length; i++) {
                try {
                    return new window.ActiveXObject(activexmodes[i]);
                } catch (e) {}
            }
        } else if (window.XMLHttpRequest) {
            return new XMLHttpRequest;
        } else {
            return false;
        }
    },
    setValues: function(obj, values) {
        if (!values) return;
        for (var key in values) {
            var newVal = values[key];
            if (newVal === undefined) {
                continue;
            }
            if (key in obj) {
                var curVal = obj[key];
                if (typeof curVal === "number" && typeof newVal === "string") {
                    var n;
                    if (newVal.indexOf("0x") === 0) n = parseInt(newVal, 16); else n = parseInt(newVal, 10);
                    if (!isNaN(n)) obj[key] = n;
                } else if (curVal instanceof Vector && newVal instanceof Array) {
                    curVal.set(parseFloat(newVal[0], 10) || 0, parseFloat(newVal[1], 10) || parseFloat(newVal[0], 10) || 0);
                } else if (curVal instanceof Vector && typeof newVal === "string") {
                    var a = newVal.split(utils._arrayDelim, 2);
                    curVal.set(parseFloat(a[0], 10) || 0, parseFloat(a[1], 10) || parseFloat(a[0], 10) || 0);
                } else if (curVal instanceof Vector && typeof newVal === "number") {
                    curVal.set(newVal, newVal);
                } else if (curVal instanceof Point && newVal instanceof Array) {
                    curVal.x = parseFloat(newVal[0], 10) || 0;
                    curVal.y = parseFloat(newVal[1], 10) || parseFloat(newVal[0], 10) || 0;
                } else if (curVal instanceof Point && typeof newVal === "string") {
                    var a2 = newVal.split(utils._arrayDelim, 2);
                    curVal.x = parseFloat(a2[0], 10) || 0;
                    curVal.y = parseFloat(a2[1], 10) || parseFloat(a2[0], 10) || 0;
                } else if (curVal instanceof Point && typeof newVal === "number") {
                    curVal.x = newVal;
                    curVal.y = newVal;
                } else if (curVal instanceof Array && typeof newVal === "string") {
                    obj[key] = newVal.split(utils._arrayDelim);
                    for (var i = 0, il = obj[key].length; i < il; ++i) {
                        var val = obj[key][i];
                        if (!isNaN(val)) obj[key][i] = parseFloat(val, 10);
                    }
                } else {
                    obj[key] = newVal;
                }
            }
        }
        return obj;
    },
    parseHitArea: function(hv) {
        var ha;
        if (hv.length % 2 !== 0 && hv.length !== 3) {
            throw "Strange number of values for hitArea! Should be a flat array of values, like: [x,y,r] for a circle, [x,y,w,h] for a rectangle, or [x,y,x,y,...] for other polygons.";
        }
        if (hv.length === 3) {
            ha = new Circle(hv[0], hv[1], hv[2]);
        } else if (hv.length === 4) {
            ha = new Rectangle(hv[0], hv[1], hv[2], hv[3]);
        } else {
            ha = new Polygon(hv);
        }
        return ha;
    },
    parseTiledProperties: function(obj) {
        if (!obj || obj.__tiledparsed) return obj;
        for (var k in obj) {
            var v = obj[k];
            if (!isNaN(v)) obj[k] = parseFloat(v, 10); else if (v === "true") obj[k] = true; else if (v === "false") obj[k] = false; else {
                try {
                    v = JSON.parse(v);
                    obj[k] = v;
                } catch (e) {}
            }
        }
        if (obj.hitArea) obj.hitArea = utils.parseHitArea(obj.hitArea);
        if (obj.static || obj.sensor) {
            obj.mass = Infinity;
            obj.inertia = Infinity;
        }
        obj.__tiledparsed = true;
        return obj;
    },
    inherits: function(child, parent, proto) {
        proto = proto || {};
        var desc = {};
        [ child.prototype, proto ].forEach(function(s) {
            Object.getOwnPropertyNames(s).forEach(function(k) {
                desc[k] = Object.getOwnPropertyDescriptor(s, k);
            });
        });
        desc.constructor = {
            value: child,
            enumerable: false,
            writable: true,
            configurable: true
        };
        child.prototype = Object.create(parent.prototype, desc);
    }
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/display/DisplayObjectContainer',['require', 'exports', 'module', '../utils/EventEmitter', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var EventEmitter = require("../utils/EventEmitter"), utils = require("../utils/utils");

var DisplayObjectContainer = module.exports = function(settings) {
    PIXI.DisplayObjectContainer.call(this);
    EventEmitter.call(this);
    utils.setValues(this, settings);
};

utils.inherits(DisplayObjectContainer, PIXI.DisplayObjectContainer, {
    resize: function() {
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.resize) o.resize.apply(o, arguments);
        }
    },
    destroy: function() {
        this.disablePhysics();
        if (this.parent) this.parent.removeChild(this);
    }
});

[ "click", "mousedown", "mouseup", "mouseupoutside", "mouseover", "mouseout", "mousemove", "tap", "touchstart", "touchend", "touchendoutside" ].forEach(function(evtname) {
    DisplayObjectContainer.prototype[evtname] = module.exports = function(e) {
        this.emit(evtname, e);
    };
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/utils/ObjectPool',['require', 'exports', 'module', './utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var utils = require("./utils");

var ObjectPool = function(type, parent) {
    this.type = type;
    this.pool = [];
    this.parent = parent;
};

utils.inherits(ObjectPool, Object, {
    create: function() {
        var o = this.pool.pop();
        if (!o) {
            o = this._construct(this.type, arguments);
            if (this.parent) this.parent.addChild(o);
        }
        o.__allocated = true;
        return o;
    },
    free: function(o) {
        if (o.__allocated) {
            o.__allocated = false;
            this.pool.push(o);
        }
    },
    _construct: function(ctor, args) {
        function F() {
            return ctor.apply(this, args);
        }
        F.prototype = ctor.prototype;
        return new F;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/camera/Camera',['require', 'exports', 'module', '../display/DisplayObjectContainer', '../utils/ObjectPool', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var DisplayObjectContainer = require("../display/DisplayObjectContainer"), ObjectPool = require("../utils/ObjectPool"), utils = require("../utils/utils");

var Camera = module.exports = function(game, settings) {
    this._bounds = new gf.Rectangle(0, 0, 0, 0);
    this._deadzone = null;
    this._target = null;
    this.size = new gf.Vector(0, 0);
    this.hSize = new gf.Vector(0, 0);
    this.game = game;
    this.fxpools = {
        flash: new gf.ObjectPool(gf.Camera.fx.Flash, this),
        fade: new gf.ObjectPool(gf.Camera.fx.Fade, this),
        shake: new gf.ObjectPool(gf.Camera.fx.Shake, this),
        scanlines: new gf.ObjectPool(gf.Camera.fx.Scanlines, this),
        close: new gf.ObjectPool(gf.Camera.fx.Close, this)
    };
    DisplayObjectContainer.call(this, settings);
};

utils.inherits(Camera, DisplayObjectContainer, {
    follow: function(spr, style) {
        if (!(spr instanceof gf.Sprite)) return this;
        this._target = spr;
        switch (style) {
          case gf.Camera.FOLLOW.PLATFORMER:
            var w = this.size.x / 8;
            var h = this.size.y / 3;
            this._deadzone = new gf.Rectangle((this.size.x - w) / 2, (this.size.y - h) / 2 - h / 4, w, h);
            break;
          case gf.Camera.FOLLOW.TOPDOWN:
            var sq4 = Math.max(this.size.x, this.size.y) / 4;
            this._deadzone = new gf.Rectangle((this.size.x - sq4) / 2, (this.size.y - sq4) / 2, sq4, sq4);
            break;
          case gf.Camera.FOLLOW.TOPDOWN_TIGHT:
            var sq8 = Math.max(this.size.x, this.size.y) / 8;
            this._deadzone = new gf.Rectangle((this.size.x - sq8) / 2, (this.size.y - sq8) / 2, sq8, sq8);
            break;
          case gf.Camera.FOLLOW.LOCKON:
          default:
            this._deadzone = null;
            break;
        }
        this.focusSprite(this._target);
        return this;
    },
    unfollow: function() {
        this._target = null;
        return this;
    },
    focusSprite: function(spr) {
        return this.focus(gf.math.round(spr.position.x) * this.game.world.scale.x, gf.math.round(spr.position.y) * this.game.world.scale.y);
    },
    focus: function(x, y) {
        y = x instanceof gf.Point ? x.y : y || 0;
        x = x instanceof gf.Point ? x.x : x || 0;
        var goToX = x - this.hSize.x, goToY = y - this.hSize.y, dx = goToX + this.game.world.position.x, dy = goToY + this.game.world.position.y;
        return this.pan(dx, dy);
    },
    pan: function(dx, dy) {
        dy = dx instanceof gf.Point ? dx.y : dy || 0;
        dx = dx instanceof gf.Point ? dx.x : dx || 0;
        if (!dx && !dy) return;
        var pos = this.game.world.position, newX = pos.x - dx, newY = pos.y - dy, b = this._bounds;
        if (this._bounds) {
            if (this._outsideBounds(-newX, -pos.y)) dx = dx < 0 ? b.x + pos.x : b.x + b.width - this.size.x + pos.x;
            if (this._outsideBounds(-pos.x, -newY)) dy = dy < 0 ? b.y + pos.y : b.y + b.height - this.size.y + pos.y;
        }
        if (dx || dy) {
            if (Math.abs(dx) > this.hSize.x || Math.abs(dy) > this.hSize.y) {
                this.game.world.setPosition(this.game.world.position.x - dx, this.game.world.position.y - dy);
                this.game.world.resize(this.size.x, this.size.y);
            } else {
                this.game.world.pan(-dx, -dy);
            }
        }
        return this;
    },
    _outsideBounds: function(x, y) {
        return !this._bounds.contains(x, y) || !this._bounds.contains(x, y + this.size.y) || !this._bounds.contains(x + this.size.x, y) || !this._bounds.contains(x + this.size.x, y + this.size.y);
    },
    resize: function(w, h) {
        this.size.set(w, h);
        this.hSize.set(Math.round(this.size.x / 2), Math.round(this.size.y / 2));
        return this;
    },
    constrain: function(shape, scaled) {
        this._bounds = shape;
        if (!scaled) {
            if (shape instanceof gf.Rectangle) {
                shape.x *= this.game.world.scale.x;
                shape.y *= this.game.world.scale.y;
                shape.width *= this.game.world.scale.x;
                shape.height *= this.game.world.scale.y;
            } else if (shape instanceof gf.Polygon) {
                for (var i = 0; i < shape.points.length; ++i) {
                    var p = shape.points[i];
                    p.x *= this.game.world.scale.x;
                    p.y *= this.game.world.scale.y;
                }
            } else {
                shape.x *= this.game.world.scale.x;
                shape.y *= this.game.world.scale.y;
            }
        }
        return this;
    },
    unconstrain: function() {
        this._bounds = null;
        return this;
    },
    update: function(dt) {
        if (this._target) {
            if (!this._deadzone) {
                this.focusSprite(this._target);
            } else {
                var moveX, moveY, dx, dy, camX = (this._target.position.x + this.game.world.position.x / this.game.world.scale.x) * this.game.world.scale.x, camY = (this._target.position.y + this.game.world.position.y / this.game.world.scale.y) * this.game.world.scale.y;
                moveX = moveY = dx = dy = 0;
                dx = camX - this._deadzone.x;
                dy = camY - this._deadzone.y;
                if (dx < 0) moveX = dx;
                if (dy < 0) moveY = dy;
                dx = camX - (this._deadzone.x + this._deadzone.width);
                dy = camY - (this._deadzone.y + this._deadzone.height);
                if (dx > 0) moveX = dx;
                if (dy > 0) moveY = dy;
                this.pan(Math.round(moveX), Math.round(moveY));
            }
        }
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var c = this.children[i];
            if (c.update) c.update(dt);
        }
        return this;
    }
});

Camera.FOLLOW = {
    PLATFORMER: 0,
    TOPDOWN: 1,
    TOPDOWN_TIGHT: 2,
    LOCKON: 3
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/display/Sprite',['require', 'exports', 'module', '../utils/EventEmitter', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var EventEmitter = require("../utils/EventEmitter"), utils = require("../utils/utils");

var Sprite = module.exports = function(tx) {
    PIXI.Sprite.call(this, tx);
    EventEmitter.call(this);
    this.type = Sprite.TYPE.NEUTRAL;
};

utils.inherits(Sprite, PIXI.Sprite, {
    destroy: function() {
        this.disablePhysics();
        if (this.parent) this.parent.removeChild(this);
    }
});

Sprite.TYPE = {
    PLAYER: "player",
    ENEMY: "enemy",
    FRIENDLY: "friendly",
    NEUTRAL: "neutral",
    COLLECTABLE: "collectable",
    TILE: "tile"
};

[ "click", "mousedown", "mouseup", "mouseupoutside", "mouseover", "mouseout", "mousemove", "tap", "touchstart", "touchend", "touchendoutside" ].forEach(function(evtname) {
    Sprite.prototype[evtname] = module.exports = function(e) {
        this.emit(evtname, e);
    };
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/display/AnimatedSprite',['require', 'exports', 'module', './Sprite', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Sprite = require("./Sprite"), utils = require("../utils/utils");

var AnimatedSprite = module.exports = function(anims, speed, start) {
    if (anims instanceof Array) {
        anims = {
            _default: {
                frames: anims
            }
        };
        start = "_default";
    } else {
        for (var a in anims) {
            if (start === undefined) start = a;
            var anim = anims[a];
            if (anim instanceof Array) anims[a] = {
                frames: anim
            }; else if (anim instanceof gf.Texture) anims[a] = {
                frames: [ anim ]
            };
        }
    }
    Sprite.call(this, anims[start].frames[0]);
    this.speed = speed || 1;
    this.loop = false;
    this.animations = anims;
    this.currentAnimation = start;
    this.currentFrame = 0;
    this.playing = false;
};

utils.inherits(AnimatedSprite, Sprite, {
    addAnimation: function(name, frames, speed, loop) {
        if (typeof name === "object") {
            this.animations[name.name] = name;
        } else {
            this.animations[name] = {
                name: name,
                frames: frames,
                speed: speed,
                loop: loop
            };
        }
    },
    gotoAndPlay: function(anim, frame) {
        if (typeof anim === "number") {
            this.currentFrame = anim;
        } else {
            this.currentFrame = frame || 0;
            this.lastRound = gf.math.round(frame || 0);
            this.currentAnimation = anim;
        }
        this.playing = true;
        this.setTexture(this.animations[this.currentAnimation].frames[this.currentFrame]);
        this.emit("frame", this.currentAnimation, this.lastRound);
    },
    gotoAndStop: function(anim, frame) {
        if (typeof anim === "number") {
            this.currentFrame = anim;
        } else {
            this.currentFrame = frame || 0;
            this.lastRound = gf.math.round(frame || 0);
            this.currentAnimation = anim;
        }
        this.playing = false;
        this.setTexture(this.animations[this.currentAnimation].frames[this.currentFrame]);
        this.emit("frame", this.currentAnimation, this.lastRound);
    },
    play: function() {
        this.playing = true;
    },
    stop: function() {
        this.playing = false;
    },
    updateTransform: function() {
        gf.Sprite.prototype.updateTransform.call(this);
        if (!this.playing) return;
        var anim = this.animations[this.currentAnimation], round, loop = anim.loop !== undefined ? anim.loop : this.loop;
        this.currentFrame += anim.speed || this.speed;
        round = gf.math.round(this.currentFrame);
        if (round < anim.frames.length) {
            if (round !== this.lastRound) {
                this.lastRound = round;
                this.setTexture(anim.frames[round]);
                this.emit("frame", this.currentAnimation, round);
            }
        } else {
            if (loop) {
                this.gotoAndPlay(0);
            } else {
                this.stop();
                this.emit("complete", this.currentAnimation);
            }
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/display/Texture',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = PIXI.Texture;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/game/GameState',['require', 'exports', 'module', '../display/DisplayObjectContainer', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var DisplayObjectContainer = require("../display/DisplayObjectContainer"), utils = require("../utils/utils");

var GameState = module.exports = function(name, settings) {
    if (typeof name === "object") {
        settings = name;
        name = Math.floor(Date.now() * Math.random()).toString();
    }
    settings = settings || {};
    this.name = name;
    this.physics = new PhysicsSystem({
        gravity: settings.gravity
    });
    this.camera = null;
    this.world = null;
    Object.defineProperty(this, "game", {
        get: function() {
            return this._game;
        },
        set: this._setGame.bind(this),
        enumerable: true
    });
    DisplayObjectContainer.call(this, settings);
    this.disable();
};

utils.inherits(GameState, DisplayObjectContainer, {
    _setGame: function(game) {
        this._game = game;
        if (this.camera) this.removeChild(this.camera);
        this.camera = new gf.Camera(game);
        this.addChild(this.camera);
        this.camera.resize(game.renderer.width, game.renderer.height);
    },
    addChild: function(obj) {
        if (obj) {
            if (obj instanceof gf.Camera || obj instanceof gf.Map) this.addChildAt(obj, 0); else if (obj instanceof gf.Gui) this.camera.addChild(obj); else this.world.addChild(obj);
        }
    },
    loadWorld: function(world) {
        if (typeof world === "string") {
            if (gf.assetCache[world]) {
                world = gf.assetCache[world];
            } else {
                throw 'World "' + world + '" needs to be preloaded before being added to a game!';
            }
        }
        this.world = new gf.TiledMap(world);
        this.addChild(this.world);
        this.world.resize(this._game.renderer.width, this._game.renderer.height);
        this.camera.constrain(new gf.Rectangle(0, 0, this.world.realSize.x, this.world.realSize.y), true);
        return this;
    },
    enable: function() {
        this.visible = true;
    },
    disable: function() {
        this.visible = false;
    },
    update: function(dt) {
        this.game.timings.cameraStart = this.game.timings._timer.now();
        this.camera.update(dt);
        this.game.timings.cameraEnd = this.game.timings._timer.now();
        this.game.timings.physicsStart = this.game.timings._timer.now();
        this.physics.update(dt);
        this.game.timings.physicsEnd = this.game.timings._timer.now();
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/utils/Clock',['require', 'exports', 'module', './utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var utils = require("./utils");

var Clock = module.exports = function(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
    this.timer = window.performance && window.performance.now ? window.performance : Date;
};

utils.inherits(Clock, Object, {
    now: function() {
        return this.timer.now();
    },
    start: function() {
        this.startTime = this.now();
        this.oldTime = this.startTime;
        this.running = true;
    },
    stop: function() {
        this.getElapsedTime();
        this.running = false;
    },
    getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
    },
    getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
        }
        if (this.running) {
            var newTime = this.now();
            diff = .001 * (newTime - this.oldTime);
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/utils/SpritePool',['require', 'exports', 'module', './utils', '../display/Sprite'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var utils = require("./utils"), Sprite = require("../display/Sprite");

var SpritePool = module.exports = function() {
    this.types = {};
    this.add("_default", Sprite);
};

utils.inherits(SpritePool, Object, {
    add: function(name, obj) {
        return this.types[name] = obj;
    },
    has: function(name) {
        return !!this.types[name];
    },
    create: function(name, texture, props) {
        if (!name || !this.types[name]) name = "_default";
        return new this.types[name](texture, props);
    },
    free: function() {
        return;
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/utils/support',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
var support = module.exports = {
    ua: navigator.userAgent.toLowerCase(),
    canvas: function() {
        try {
            return !!window.CanvasRenderingContext2D && !!document.createElement("canvas").getContext("2d");
        } catch (e) {
            return false;
        }
    }(),
    webgl: function() {
        try {
            return !!window.WebGLRenderingContext && !!document.createElement("canvas").getContext("experimental-webgl");
        } catch (e) {
            return false;
        }
    }(),
    workers: !!window.Worker,
    blobUrls: !!window.Blob && !!window.URL && !!window.URL.createObjectURL,
    typedArrays: !!window.ArrayBuffer,
    fileapi: !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob,
    webAudio: !!window.AudioContext || !!window.webkitAudioContext || !!window.mozAudioContext,
    htmlAudio: !!document.createElement("audio").canPlayType,
    localStorage: !!window.localStorage,
    touch: "createTouch" in document || "ontouchstart" in window || navigator.isCocoonJS,
    gamepad: !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || navigator.userAgent.indexOf("Firefox/") !== -1
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/game/Game',['require', 'exports', 'module', './GameState', '../utils/EventEmitter', '../utils/Clock', '../utils/SpritePool', '../utils/support', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var GameState = require("./GameState"), EventEmitter = require("../utils/EventEmitter"), Clock = require("../utils/Clock"), SpritePool = require("../utils/SpritePool"), support = require("../utils/support"), utils = require("../utils/utils");

var Game = module.exports = function(contId, settings) {
    EventEmitter.call(this);
    this.container = document.getElementById(contId);
    if (!this.container) this.container = document.body;
    this.renderMethod = "webgl";
    this.players = [];
    this.stage = new PIXI.Stage(settings.background, settings.interactive !== undefined ? settings.interactive : true);
    this.clock = new Clock(false);
    this.renderer = null;
    if (settings.renderMethod) {
        if (!support[settings.renderMethod]) {
            throw "Render method " + settings.renderMethod + " is not supported by this browser!";
        }
        this.renderMethod = settings.renderMethod;
    } else {
        if (support.webgl) this.renderMethod = "webgl"; else if (support.canvas) this.renderMethod = "canvas"; else {
            throw "Neither WebGL nor Canvas is supported by this browser!";
        }
    }
    if (this.renderMethod === "webgl") {
        this.renderer = new PIXI.WebGLRenderer(settings.width, settings.height, settings.view, settings.transparent);
    } else if (this.renderMethod === "canvas") {
        this.renderer = new PIXI.CanvasRenderer(settings.width, settings.height, settings.view, settings.transparent);
    }
    this.MAX_Z = 500;
    this.loader = new AssetLoader;
    this.spritepool = new SpritePool;
    this.input = new InputManager(this.renderer.view);
    this.states = {};
    this.activeState = null;
    this._defaultState = new GameState("_default");
    this.timings = {
        _timer: window.performance && window.performance.now ? window.performance : Date
    };
    if (!settings.view) this.container.appendChild(this.renderer.view);
    utils.setValues(this, settings);
    this.addState(this._defaultState);
    this.enableState("_default");
    var self = this;
    [ "audio", "physics", "camera", "world" ].forEach(function(prop) {
        self.__defineGetter__(prop, function() {
            return self.activeState[prop];
        });
    });
    var view = this.renderer.view;
    if (!view.getAttribute("tabindex")) view.setAttribute("tabindex", "1");
    view.focus();
    view.addEventListener("click", function() {
        view.focus();
    }, false);
};

utils.inherits(Game, Object, {
    resize: function(w, h) {
        this.renderer.resize(w, h);
        for (var i = 0, il = this.stage.children.length; i < il; ++i) {
            var o = this.stage.children[i];
            if (o.resize) o.resize(w, h);
        }
        return this;
    },
    addChild: function(obj) {
        this.activeState.addChild(obj);
        return this;
    },
    removeChild: function(obj) {
        if (obj) {
            if (obj instanceof Gui) this.camera.removeChild(obj); else this.world.removeChild(obj);
        }
        return this;
    },
    requestFullscreen: function() {
        var elem = this.renderer.view;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        }
    },
    addState: function(state) {
        var name = state.name;
        if (!name) {
            throw "No state name could be determined, did you give the state a name when you created it?";
        } else if (this.states[name]) {
            throw 'A state with the name "' + name + '" already exists, did you try to add it twice?';
        } else {
            this.states[name] = state;
            this.stage.addChild(state);
            state.game = this;
        }
        return this;
    },
    removeState: function(state) {
        var name = typeof state === "string" ? state : state.name;
        if (!name) {
            throw "No state name could be determined, are you sure you passed me a game state?";
        } else if (!this.states[name]) {
            throw 'A state with the name "' + name + '" does not exist, are you sure you added it?';
        } else {
            if (name === "_default") return;
            if (name === this.activeState.name) {
                this.enableState("_default");
            }
            delete this.states[name];
        }
        return this;
    },
    enableState: function(state) {
        var name = typeof state === "string" ? state : state.name;
        if (this.activeState) this.activeState.disable();
        this.activeState = this.states[name];
        this.activeState.enable();
        return this;
    },
    loadWorld: function(world) {
        this.activeState.loadWorld(world);
        return this;
    },
    render: function() {
        this.clock.start();
        this._tick();
        return this;
    },
    _tick: function() {
        this.timings.tickStart = this.timings._timer.now();
        window.requestAnimFrame(this._tick.bind(this));
        var dt = this.clock.getDelta();
        this.timings.inputStart = this.timings._timer.now();
        this.input.update(dt);
        this.timings.inputEnd = this.timings._timer.now();
        this.timings.stateStart = this.timings._timer.now();
        this.activeState.update(dt);
        this.timings.stateEnd = this.timings._timer.now();
        this.timings.renderStart = this.timings._timer.now();
        this.renderer.render(this.stage);
        this.timings.renderEnd = this.timings._timer.now();
        this.timings.tickEnd = this.timings._timer.now();
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/map/Tile',['require', 'exports', 'module', '../display/Sprite', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var Sprite = require("../display/Sprite"), utils = require("../utils/utils");

var Tile = module.exports = function(texture) {
    this.collisionType = Tile.TYPE.NONE;
    Sprite.call(this, texture);
    this.type = Sprite.TYPE.TILE;
};

utils.inherits(Tile, Sprite, {
    onCollision: function(obj) {
        Sprite.prototype.onCollision.call(this, obj);
        switch (this.collisionType) {
          case Tile.TYPE.SOLID:
            obj.setVelocity(0);
            break;
        }
    }
});

Tile.TYPE = {
    NONE: "none",
    SOLID: "solid",
    CLIFF: "cliff",
    LADDER: "ladder",
    WATER: "water",
    DEEP_WATER: "deep_water"
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/map/Layer',['require', 'exports', 'module', '../display/DisplayObjectContainer', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var DisplayObjectContainer = require("../display/DisplayObjectContainer"), utils = require("../utils/utils");

var Layer = module.exports = function(layer) {
    this.name = "";
    this.size = new gf.Vector(layer.width || 0, layer.height || 0);
    DisplayObjectContainer.call(this, layer);
};

utils.inherits(Layer, DisplayObjectContainer, {
    pan: function() {}
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/map/Map',['require', 'exports', 'module', '../display/DisplayObjectContainer', '../math/Vector', '../utils/utils'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
var DisplayObjectContainer = require("../display/DisplayObjectContainer"), Vector = require("../math/Vector"), utils = require("../utils/utils");

var Map = module.exports = function(map) {
    this.size = new Vector(map.width, map.height);
    DisplayObjectContainer.call(this, map);
};

utils.inherits(Map, DisplayObjectContainer, {
    pan: function(x, y) {
        y = x.y !== undefined ? x.y : y || 0;
        x = x.x !== undefined ? x.x : x || 0;
        this.position.x += x;
        this.position.y += y;
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.pan) o.pan(x, y);
        }
    },
    findLayer: function(name) {
        for (var i = 0, il = this.children.length; i < il; ++i) {
            var o = this.children[i];
            if (o.name === name) return o;
        }
    }
});
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/math/math',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
var math = module.exports = {
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    SEED: Math.random(),
    round: function(n) {
        return ~~(n + (n > 0 ? .5 : -.5));
    },
    clamp: function(n, min, max) {
        return Math.max(min, Math.min(max, n));
    },
    truncate: function(n) {
        return n > 0 ? Math.floor(n) : Math.ceil(n);
    },
    snap: function(n, gap, offset) {
        if (gap === 0) return n;
        n -= offset;
        n = gap * Math.round(n / gap);
        return offset + n;
    },
    snapFloor: function(n, gap, offset) {
        if (gap === 0) return n;
        n -= offset;
        n = gap * Math.floor(n / gap);
        return offset + n;
    },
    snapCeil: function(n, gap, offset) {
        if (gap === 0) return n;
        n -= offset;
        n = gap * Math.ceil(n / gap);
        return offset + n;
    },
    radiansToDegrees: function(angle) {
        return angle * math.RAD_TO_DEG;
    },
    degreesToRadians: function(angle) {
        return angle * math.DEG_TO_RAD;
    },
    angleBetween: function(pos1, pos2) {
        return Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x);
    },
    randomBool: function(chance) {
        if (chance === undefined) chance = 50;
        if (chance <= 0) return false;
        if (chance >= 100) return true;
        if (Math.random() * 100 >= chance) return false;
        return true;
    },
    randomInt: function(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    },
    randomSign: function(chance) {
        return math.randomBool(chance) ? 1 : -1;
    },
    randomElement: function(array, start, len) {
        if (!start || start < 0) start = start || 0;
        if (!len || len < 1 || len > array.length - start) len = array.length - start;
        if (!array || len < 1) return null;
        return array[start + Math.floor(Math.random() * len)];
    }
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define(
  'core/math/Ellipse',['require','exports','module'],function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = PIXI.Ellipse;
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('core/core',['require', 'exports', 'module', './plugin', './camera/Camera', './display/DisplayObjectContainer', './display/Sprite', './display/AnimatedSprite', './display/Texture', './game/Game', './game/GameState', './map/Tile', './map/Layer', './map/Map', './math/math', './math/Circle', './math/Ellipse', './math/Polygon', './math/Rectangle', './math/Vector', './utils/utils', './utils/support', './utils/Clock', './utils/EventEmitter', './utils/ObjectPool', './utils/SpritePool'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = {
    version: "@@VERSION",
    assetCache: {},
    plugin: require("./plugin"),
    Camera: require("./camera/Camera"),
    DisplayObjectContainer: require("./display/DisplayObjectContainer"),
    Sprite: require("./display/Sprite"),
    AnimatedSprite: require("./display/AnimatedSprite"),
    Texture: require("./display/Texture"),
    Game: require("./game/Game"),
    GameState: require("./game/GameState"),
    Tile: require("./map/Tile"),
    Layer: require("./map/Layer"),
    Map: require("./map/Map"),
    math: require("./math/math"),
    Circle: require("./math/Circle"),
    Ellipse: require("./math/Ellipse"),
    Polygon: require("./math/Polygon"),
    Rectangle: require("./math/Rectangle"),
    Vector: require("./math/Vector"),
    utils: require("./utils/utils"),
    support: require("./utils/support"),
    Clock: require("./utils/Clock"),
    EventEmitter: require("./utils/EventEmitter"),
    ObjectPool: require("./utils/ObjectPool"),
    SpritePool: require("./utils/SpritePool")
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);
(function (window) {
  define('bundle.js',['require', 'exports', 'module', './core/core'], 
  function (require, exports, module) {
  // uRequire: start body of original nodejs module
module.exports = {
    core: require("./core/core")
};
// uRequire: end body of original nodejs module


return module.exports;
}
);
})(__global);

      return require('bundle.js');
  };

  if (__isAMD) {
      define([], factory);
  } else {
      if (__isNode) {
          module.exports = factory();
      } else {
          factory();
      }
  }
})();